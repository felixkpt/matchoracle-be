<?php

namespace App\Services\GameSources\Forebet;

use App\Models\Competition;
use App\Models\Country;
use App\Models\Game;
use App\Models\GameScore;
use App\Models\GameScoreStatus;
use App\Models\GameSource;
use App\Models\Referee;
use App\Models\Season;
use App\Models\Team;
use Illuminate\Support\Carbon;
use Illuminate\Support\Str;

/**
 * Class BaseHandlerController
 * 
 * A base controller for handling Forebet game sources.
 * It provides common properties and initialization logic.
 */
trait ForebetInitializationTrait
{
    /**
     * @var string The base URL for the Forebet source.
     */
    public $url;

    /**
     * @var array Configuration settings for the handler.
     */
    public $config;

    /**
     * @var string The source URL for Forebet.
     */
    public $sourceUrl;

    /**
     * @var array Request preferences for HTTP requests.
     */
    public $reqPrefs = array();

    /**
     * @var int The ID of the Forebet game source.
     */
    public $sourceId;

    public $logChannel = 'automation';

    protected $jobId;

    /**
     * Constructor for ForebetInitializationTrait.
     */
    public function __construct()
    {
        $this->initialize();
    }

    function matchMessage($message, $status = 422)
    {
        $arr = ['message' => $message, 'status' => $status];
        if (request()->without_response) return $arr;
        return response($arr, $status);
    }

    /**
     * Initialize the Forebet game source handler.
     * This method sets up the configuration, source URL, request preferences,
     * and updates or creates the GameSource record in the database.
     */
    public function initialize()
    {
        // Set the base URL for the Forebet source
        $this->config['sourceUrl'] = 'https://www.forebet.com/';

        // Assign the source URL
        $this->sourceUrl = $this->config['sourceUrl'];

        // Set the HTTP method for requests
        $this->reqPrefs['http']['method'] = 'GET';

        // Update or create the GameSource record in the database
        $this->sourceId = GameSource::updateOrCreate(
            [
                'url' => $this->sourceUrl,
            ],
            [
                'name' => 'Mathematical football predictions /forebets/ and football statistics',
                'url' => $this->sourceUrl,
                'description' => 'Forebet presents mathematical football predictions generated by computer algorithm on the basis of statistics. Predictions, statistics, live-score, match previews and detailed analysis for more than 700 football leagues',
                'priority_number' => 2,
                'status_id' => activeStatusId(),
                'user_id' => auth()->id() ?? 0,
            ]
        )->id ?? 0;
    }

    private function storeScores($game, $score)
    {
        $full_time_results = $score['full_time_results'];

        if (Str::contains($full_time_results, ':')) {
            return false;
        }

        $winner = ($score['postponed'] ?? false) ? Str::upper('PST') : null;
        if (!$winner) {
            $winner = ($score['cancelled'] ?? false) ? Str::upper('CANC') : null;
        }

        $home_scores_full_time = null;
        $away_scores_full_time = null;

        if (Str::contains($full_time_results, '-')) {
            [$home_scores_full_time, $away_scores_full_time] = array_map('trim', explode('-', $full_time_results));

            $winner = $this->determineWinner($home_scores_full_time, $away_scores_full_time);
        }

        $data = [
            'game_id' => $game->id,
            'winner' => $winner,
            'duration' => null,
            'home_scores_full_time' => $home_scores_full_time,
            'away_scores_full_time' => $away_scores_full_time,
        ];

        if (isset($score['half_time_results']) && Str::contains($score['half_time_results'], '-')) {
            [$home_scores_half_time, $away_scores_half_time] = array_map('trim', explode('-', $score['half_time_results']));

            $data['home_scores_half_time'] = $home_scores_half_time;
            $data['away_scores_half_time'] = $away_scores_half_time;
        }

        $game_score_status_id = gameScoresStatus('scheduled');
        if ($winner) {
            $score = GameScore::updateOrCreate(
                ['game_id' => $game->id],
                $data
            );

            $game_score_status_id = $this->determineGameScoreStatus($game, $data, $score);

            $game->update(['game_score_status_id' => $game_score_status_id, 'status' => GameScoreStatus::find($game_score_status_id)->name]);
        }

        return $game_score_status_id;
    }

    private function determineWinner($home_scores, $away_scores)
    {
        if ($home_scores > $away_scores) {
            return 'HOME_TEAM';
        } elseif ($home_scores == $away_scores) {
            return 'DRAW';
        } else {
            return 'AWAY_TEAM';
        }
    }

    private function determineGameScoreStatus($game, $data, $score)
    {
        if (in_array($game->game_score_status_id, unsettledGameScoreStatuses())) {
            if (isset($data['home_scores_half_time']) && $data['home_scores_half_time'] >= 0) {
                return gameScoresStatus('ft-and-ht-results');
            } elseif ($score->winner == Str::upper('postponed')) {
                return gameScoresStatus('postponed');
            } elseif ($score->winner == Str::upper('cancelled')) {
                return gameScoresStatus('cancelled');
            } elseif ($score->home_scores_half_time === null) {
                return gameScoresStatus('ft-results-only');
            }
        }

        return gameScoresStatus('ft-and-ht-results');
    }

    private function syncReferees($game, $match)
    {

        if (isset($match->referees)) {

            $referees = $match->referees;
            $refsArr = [];
            foreach ($referees as $referee) {

                $country = Country::where('name', $referee->nationality)->first();

                $ref = Referee::updateOrCreate([
                    'name' => $referee->name,
                    'type' => $referee->type,
                    'country_id' => $country->id ?? 0,
                ]);

                if ($ref) {
                    $refsArr[] = $ref->id;
                }
            }

            $game->referees()->sync($refsArr);
        }
    }

    function prepareFetch($competition_id, $season_id = null)
    {

        if ($season_id) {
            $season = Season::find($season_id);
        } else {
            $season = Season::where('competition_id', $competition_id)->where('is_current', true)->first();
        }

        $season_str = null;
        if ($season)
            $season_str = Str::before($season->start_date, '-') . '-' . Str::before($season->end_date, '-');

        $competition = Competition::whereHas('gameSources', function ($q) use ($competition_id) {
            $q->where('competition_id', $competition_id);
        })->first();

        if (!$competition) {
            $message = 'Competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;

            return response(['message' => $message], 404);
        }

        // Access the source_id value for the pivot
        $source = $competition->gameSources()->where(function ($q) use ($competition_id) {
            $q->where('game_source_id', $this->sourceId)->where('competition_id', $competition_id);
        })->first()->pivot;

        if (!$source) {
            $message = 'Source for competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 404);
        }

        if (!$source->is_subscribed) {
            $message = 'Source #' . $source->source_id . ' not subscribed.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 402);
        }

        return ['message' => true, 'data' => [$competition, $season, $source, $season_str]];
    }
}
