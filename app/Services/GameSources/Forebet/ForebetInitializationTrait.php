<?php

namespace App\Services\GameSources\Forebet;

use App\Models\Competition;
use App\Models\Country;
use App\Models\Game;
use App\Models\GameScore;
use App\Models\GameScoreStatus;
use App\Models\GameSource;
use App\Models\Referee;
use App\Models\Season;
use App\Models\Team;
use App\Services\ClientHelper\Client;
use App\Utilities\GameUtility;
use Illuminate\Http\Client\ConnectionException;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use Illuminate\Support\FacadesStorage;
use Illuminate\Support\Str;

/**
 * Class BaseHandlerController
 * 
 * A base controller for handling Forebet game sources.
 * It provides common properties and initialization logic.
 */
trait ForebetInitializationTrait
{
    /**
     * @var string The base URL for the Forebet source.
     */
    public $url;

    /**
     * @var array Configuration settings for the handler.
     */
    public $config;

    /**
     * @var string The source URL for Forebet.
     */
    public $sourceUrl;

    /**
     * @var array Request preferences for HTTP requests.
     */
    public $reqPrefs = array();

    /**
     * @var int The ID of the Forebet game source.
     */
    public $sourceId;

    public $logChannel = 'automation';

    protected $jobId;

    /**
     * Constructor for ForebetInitializationTrait.
     */
    public function __construct()
    {
        $this->initialize();
    }

    function matchMessage($message, $status = 422)
    {
        $arr = ['message' => $message, 'status' => $status];
        if (request()->without_response) return $arr;
        return response($arr, $status);
    }

    /**
     * Initialize the Forebet game source handler.
     * This method sets up the configuration, source URL, request preferences,
     * and updates or creates the GameSource record in the database.
     */
    public function initialize()
    {
        // Set the base URL for the Forebet source
        $this->config['sourceUrl'] = 'https://www.forebet.com/';

        // Assign the source URL
        $this->sourceUrl = $this->config['sourceUrl'];

        // Set the HTTP method for requests
        $this->reqPrefs['http']['method'] = 'GET';

        // Update or create the GameSource record in the database
        $this->sourceId = GameSource::updateOrCreate(
            [
                'url' => $this->sourceUrl,
            ],
            [
                'name' => 'Mathematical football predictions /forebets/ and football statistics',
                'url' => $this->sourceUrl,
                'description' => 'Forebet presents mathematical football predictions generated by computer algorithm on the basis of statistics. Predictions, statistics, live-score, match previews and detailed analysis for more than 700 football leagues',
                'priority_number' => 2,
                'status_id' => activeStatusId(),
                'user_id' => auth()->id() ?? 0,
            ]
        )->id ?? 0;
    }

    private function storeScores($game, $score, $expectsHtResults = false)
    {
        $full_time_results = $score['full_time_results'];

        if (Str::contains($full_time_results, ':')) {
            return false;
        }

        $winner = ($score['postponed'] ?? false) ? Str::upper('PST') : null;
        if (!$winner) {
            $winner = ($score['cancelled'] ?? false) ? Str::upper('CANC') : null;
        }

        $home_scores_full_time = null;
        $away_scores_full_time = null;

        if (Str::contains($full_time_results, '-')) {
            [$home_scores_full_time, $away_scores_full_time] = array_map('trim', explode('-', $full_time_results));

            $winner = $this->determineWinner($home_scores_full_time, $away_scores_full_time);
        }

        $data = [
            'game_id' => $game->id,
            'winner' => $winner,
            'duration' => null,
            'home_scores_full_time' => $home_scores_full_time,
            'away_scores_full_time' => $away_scores_full_time,
        ];

        if (isset($score['half_time_results']) && Str::contains($score['half_time_results'], '-')) {
            [$home_scores_half_time, $away_scores_half_time] = array_map('trim', explode('-', $score['half_time_results']));

            $data['home_scores_half_time'] = $home_scores_half_time;
            $data['away_scores_half_time'] = $away_scores_half_time;
        }

        $game_score_status_id = gameScoresStatus('scheduled');
        if ($winner) {
            $score = GameScore::updateOrCreate(
                ['game_id' => $game->id],
                $data
            );

            $game_score_status_id = $this->determineGameScoreStatus($game, $data, $score);

            $game->update(['game_score_status_id' => $game_score_status_id, 'status' => GameScoreStatus::find($game_score_status_id)->name]);
        }

        (new GameUtility())->updateMatchStatus($game, $expectsHtResults ? 'ht_status' : 'ft_status');

        return $game_score_status_id;
    }

    private function determineWinner($home_scores, $away_scores)
    {
        if ($home_scores > $away_scores) {
            return 'HOME_TEAM';
        } elseif ($home_scores == $away_scores) {
            return 'DRAW';
        } else {
            return 'AWAY_TEAM';
        }
    }

    private function determineGameScoreStatus($game, $data, $score)
    {
        if (in_array($game->game_score_status_id, unsettledGameScoreStatuses())) {
            if (isset($data['home_scores_half_time']) && $data['home_scores_half_time'] >= 0) {
                return gameScoresStatus('ft-and-ht-results');
            } elseif ($score->winner == Str::upper('postponed')) {
                return gameScoresStatus('postponed');
            } elseif ($score->winner == Str::upper('cancelled')) {
                return gameScoresStatus('cancelled');
            } elseif ($score->home_scores_half_time === null) {
                return gameScoresStatus('ft-results-only');
            }
        }

        return gameScoresStatus('ft-and-ht-results');
    }

    private function syncReferees($game, $match)
    {

        if (isset($match->referees)) {

            $referees = $match->referees;
            $refsArr = [];
            foreach ($referees as $referee) {

                $country = Country::where('name', $referee->nationality)->first();

                $ref = Referee::updateOrCreate([
                    'name' => $referee->name,
                    'type' => $referee->type,
                    'country_id' => $country->id ?? 0,
                ]);

                if ($ref) {
                    $refsArr[] = $ref->id;
                }
            }

            $game->referees()->sync($refsArr);
        }
    }

    function prepareFetch($competition_id, $season_id = null)
    {

        if ($season_id) {
            $season = Season::find($season_id);
        } else {
            $season = Season::where('competition_id', $competition_id)->where('is_current', true)->first();
        }

        $season_str = null;
        if ($season)
            $season_str = Str::before($season->start_date, '-') . '-' . Str::before($season->end_date, '-');

        $competition = Competition::whereHas('gameSources', function ($q) use ($competition_id) {
            $q->where('competition_id', $competition_id);
        })->first();

        if (!$competition) {
            $message = 'Competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;

            return response(['message' => $message], 404);
        }

        // Access the source_id value for the pivot
        $source = $competition->gameSources()->where(function ($q) use ($competition_id) {
            $q->where('game_source_id', $this->sourceId)->where('competition_id', $competition_id);
        })->first()->pivot;

        if (!$source) {
            $message = 'Source for competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 404);
        }

        if (!$source->is_subscribed) {
            $message = 'Source #' . $source->source_id . ' not subscribed.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 402);
        }

        return ['message' => true, 'data' => [$competition, $season, $source, $season_str]];
    }

    /**
     * Fetch a URL with caching.
     *
     * @param string $url
     * @param string $cachePath
     * @param int $ttlMinutes            Cache time-to-live in minutes.
     * @param string $disk               Storage disk to use (default 'local').
     * @param string|null $logChannel    Optional log channel name.
     *
     * @return string|null  The content or null if failed.
     */
    protected function fetchWithCacheV1(
        string $url,
        string $cachePath,
        int $ttlMinutes = 10,
        string $disk = 'local',
        ?string $logChannel = null
    ) {
        $cachePath = 'cached/' . $cachePath;

        // Calculate expiry timestamp
        $expiryTimestamp = now()->addMinutes($ttlMinutes)->format('YmdHis');
        $baseKey = $cachePath . "/" . md5($url);
        $cacheFile = "{$baseKey}_exp{$expiryTimestamp}.html";

        // Find an existing cache file in the right directory
        $cacheDir = $cachePath; // e.g. cached/abbreviations_html
        $existingFile = collect(Storage::disk($disk)->files($cacheDir))
            ->first(fn($file) => str_starts_with($file, $baseKey . '_exp'));

        if ($existingFile) {
            preg_match('/_exp(\d{14})\.html$/', $existingFile, $matches);
            if (!empty($matches[1])) {
                $expiryTime = Carbon::createFromFormat('YmdHis', $matches[1]);
                if (now()->lt($expiryTime)) {
                    if ($logChannel) {
                        Log::channel($logChannel)->info("Reusing cached content for {$url}");
                    }
                    return Storage::disk($disk)->get($existingFile);
                }
            }
        }

        // Fetch fresh
        try {
            $content = Client::get($url);
            if (!$content) {
                return null;
            }

            if (str_contains($content, '<table class="main"')) {
                // Clean up old cache files for this key
                if ($existingFile) {
                    Storage::disk($disk)->delete($existingFile);
                }
                // Save new file with expiry info
                Storage::disk($disk)->put($cacheFile, $content);
            }

            return $content;
        } catch (ConnectionException $e) {
            if ($logChannel) {
                Log::channel($logChannel)->error("Connection error fetching {$url}: {$e->getMessage()}");
            }
            return null;
        } catch (\Exception $e) {
            if ($logChannel) {
                Log::channel($logChannel)->critical("Unexpected error fetching {$url}: {$e->getMessage()}");
            }
            return null;
        }
    }

    /**
     * Fetch a URL with caching.
     *
     * @param string $url
     * @param string $cachePath
     * @param int $ttlMinutes            Cache time-to-live in minutes.
     * @param string $disk               Storage disk to use (default 'local').
     * @param string|null $logChannel    Optional log channel name.
     *
     * @return string|null  The content or null if failed.
     */
    protected function fetchWithCacheV2(
        string $url,
        string $cachePath,
        int $ttlMinutes = 10,
        string $disk = 'local',
        ?string $logChannel = null
    ) {
        $t0 = microtime(true);
        $logger = $logChannel ? Log::channel($logChannel) : Log::channel('stack');
        $trace = class_basename($this) . '-' . ($this->jobId ?? 'n/a');

        // Normalize cache path and ensure directory exists
        $cachePath = 'cached/automation/' . trim($cachePath, '/');
        if (!Storage::disk($disk)->exists($cachePath)) {
            Storage::disk($disk)->makeDirectory($cachePath);
            $logger->debug("$trace: STEP 0: Created cache directory", ['disk' => $disk, 'cachePath' => $cachePath]);
        } else {
            $logger->debug("$trace: STEP 0: Using cache directory", ['disk' => $disk, 'cachePath' => $cachePath]);
        }

        // Prepare keys (machine + human-readable)
        $newExpiryCarbon   = now()->addMinutes($ttlMinutes);
        $newExpiryRaw      = $newExpiryCarbon->format('YmdHis');   // machine
        $newExpiryHuman    = $newExpiryCarbon->toDateTimeString(); // human-readable
        $baseKey           = $cachePath . '/' . md5($url);

        $logger->debug("$trace: STEP 1: Built cache keys", [
            'url' => $url,
            'baseKey' => $baseKey,
            'requestedTtlMinutes' => $ttlMinutes,
            'newExpiryTimestamp' => $newExpiryRaw,
            'newExpiryAt' => $newExpiryHuman,
        ]);

        // Find existing cache file
        $files = Storage::disk($disk)->files($cachePath);
        $existingFile = collect($files)->first(fn($file) => str_starts_with($file, $baseKey . '_exp'));
        $logger->debug("$trace: STEP 2: Scanned for existing cache", [
            'found' => (bool) $existingFile,
            'existingFile' => $existingFile,
            'filesCount' => count($files),
        ]);

        if ($existingFile) {
            if (preg_match('/_exp(\d{14})\.html$/', $existingFile, $matches)) {
                $expiryTime   = \Carbon\Carbon::createFromFormat('YmdHis', $matches[1]);
                $remaining    = now()->diffInMinutes($expiryTime, false);

                $logger->debug("$trace: STEP 3: Parsed existing expiry", [
                    'expiryAt' => $expiryTime->toDateTimeString(),
                    'expiryRaw' => $matches[1],
                    'remainingHours' => round($remaining / 60),
                    'now' => now()->toDateTimeString(),
                ]);

                if (now()->lt($expiryTime)) {
                    if ($remaining <= $ttlMinutes) {
                        // Cache is valid and within TTL window → reuse
                        $logger->info("$trace: Reusing cached content", [
                            'url' => $url,
                            'cacheFile' => $existingFile,
                            'remainingMinutes' => $remaining,
                            'requestedTtl' => $ttlMinutes,
                            'expiresAt' => $expiryTime->toDateTimeString(),
                        ]);
                        $content = Storage::disk($disk)->get($existingFile);
                        return [$content, true];
                    } else {
                        // Existing cache lasts longer than allowed → refresh
                        $logger->info("$trace: Refreshing cache (existing expiry too far)", [
                            'url' => $url,
                            'cacheFile' => $existingFile,
                            'remainingMinutes' => $remaining,
                            'requestedTtl' => $ttlMinutes,
                            'expiresAt' => $expiryTime->toDateTimeString(),
                        ]);
                        Storage::disk($disk)->delete($existingFile);
                    }
                }
            } else {
                $logger->warning("$trace: Could not parse expiry from filename. Deleting and refetching.", [
                    'file' => $existingFile,
                ]);
                Storage::disk($disk)->delete($existingFile);
            }
        }

        // Fetch fresh
        try {
            $logger->debug("$trace: STEP 4: Fetching fresh content", ['url' => $url]);
            $tFetch = microtime(true);
            $content = Client::get($url); // keep your existing client
            $fetchMs = (int) round((microtime(true) - $tFetch) * 1000);

            if (!$content) {
                $logger->warning("$trace: Empty response received", ['url' => $url, 'durationMs' => $fetchMs]);
                return [null, false];
            }

            $bytes = strlen($content);
            $logger->debug("$trace: STEP 4b: Fetch complete", [
                'url' => $url,
                'durationMs' => $fetchMs,
                'bytes' => $bytes,
            ]);

            // Only cache if the expected marker exists
            if (str_contains($content, '<table class="main"')) {
                $cacheFile = "{$baseKey}_exp{$newExpiryRaw}.html";
                Storage::disk($disk)->put($cacheFile, $content);
                $logger->info("$trace: Cached fresh content", [
                    'cacheFile' => $cacheFile,
                    'expiresAt' => $newExpiryHuman,
                    'expiresRaw' => $newExpiryRaw,
                    'bytes' => $bytes,
                ]);
            } else {
                $logger->warning("$trace: Content did not match expected selector. Not caching.", [
                    'selector' => 'table.main',
                    'url' => $url,
                ]);
            }

            $logger->debug("$trace: STEP 5: Done", [
                'totalElapsedMs' => (int) round((microtime(true) - $t0) * 1000),
            ]);

            return [$content, false]; // fresh fetch, not cached

        } catch (ConnectionException $e) {
            $logger->error("$trace: Connection error fetching", [
                'url' => $url,
                'error' => $e->getMessage(),
            ]);
            return [null, false];
        } catch (\Exception $e) {
            $logger->critical("$trace: Unexpected error fetching", [
                'url' => $url,
                'error' => $e->getMessage(),
            ]);
            return [null, false];
        }
    }
}
