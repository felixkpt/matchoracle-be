<?php

namespace App\Services\GameSources\Forebet;

use App\Models\Competition;
use App\Models\Country;
use App\Models\Game;
use App\Models\GameScore;
use App\Models\GameScoreStatus;
use App\Models\GameSource;
use App\Models\Referee;
use App\Models\Season;
use App\Models\Team;
use Illuminate\Support\Carbon;
use Illuminate\Support\Facades\DB;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Str;

/**
 * Class BaseHandlerController
 * 
 * A base controller for handling Forebet game sources.
 * It provides common properties and initialization logic.
 */
trait ForebetInitializationTrait
{
    /**
     * @var string The base URL for the Forebet source.
     */
    public $url;

    /**
     * @var array Configuration settings for the handler.
     */
    public $config;

    /**
     * @var string The source URL for Forebet.
     */
    public $sourceUrl;

    /**
     * @var array Request preferences for HTTP requests.
     */
    public $reqPrefs = array();

    /**
     * @var int The ID of the Forebet game source.
     */
    public $sourceId;

    /**
     * Constructor for ForebetInitializationTrait.
     */
    public function __construct()
    {
        $this->initialize();
    }

    function matchMessage($message, $status = 422)
    {
        $arr = ['message' => $message];
        if (request()->without_response) return $arr;
        return response($arr, $status);
    }

    /**
     * Initialize the Forebet game source handler.
     * This method sets up the configuration, source URL, request preferences,
     * and updates or creates the GameSource record in the database.
     */
    public function initialize()
    {
        // Set the base URL for the Forebet source
        $this->config['sourceUrl'] = 'https://www.forebet.com/';

        // Assign the source URL
        $this->sourceUrl = $this->config['sourceUrl'];

        // Set the HTTP method for requests
        $this->reqPrefs['http']['method'] = 'GET';

        // Update or create the GameSource record in the database
        $this->sourceId = GameSource::updateOrCreate(
            [
                'url' => $this->sourceUrl,
            ],
            [
                'name' => 'Mathematical football predictions /forebets/ and football statistics',
                'url' => $this->sourceUrl,
                'description' => 'Forebet presents mathematical football predictions generated by computer algorithm on the basis of statistics. Predictions, statistics, live-score, match previews and detailed analysis for more than 700 football leagues',
                'priority_number' => 2,
                'status_id' => activeStatusId(),
                'user_id' => auth()->id() ?? 0,
            ]
        )->id ?? 0;
    }

    private function storeScores($game, $score)
    {

        $full_time_results = $score['full_time_results'];

        if (Str::contains($full_time_results, ':')) return false;

        $winner = isset($score['postponed']) ? Str::upper('postponed') : null;

        $home_scores_full_time = null;
        $away_scores_full_time = null;

        if (Str::contains($full_time_results, '-')) {
            $arr = explode('-', $full_time_results);
            $home_scores_full_time = trim($arr[0]);
            $away_scores_full_time = trim($arr[1]);

            if ($home_scores_full_time > $away_scores_full_time)
                $winner = 'HOME_TEAM';
            elseif ($home_scores_full_time == $away_scores_full_time)
                $winner = 'DRAW';
            elseif ($home_scores_full_time < $away_scores_full_time)
                $winner = 'AWAY_TEAM';
        }

        $data = [
            'game_id' => $game->id,
            'winner' => $winner,
            'duration' => null,

            'home_scores_full_time' => $home_scores_full_time,
            'away_scores_full_time' => $away_scores_full_time,
        ];

        if (isset($score['half_time_results'])) {

            $half_time_results = $score['half_time_results'];

            if (Str::contains($half_time_results, '-')) {
                $arr = explode('-', $half_time_results);
                $home_scores_half_time = trim($arr[0]);
                $away_scores_half_time = trim($arr[1]);

                $data['home_scores_half_time'] = $home_scores_half_time;
                $data['away_scores_half_time'] = $away_scores_half_time;
            }
        }

        $game_score_status_id = gameScoresStatus('scheduled');
        if ($winner) {

            $score = GameScore::updateOrCreate(
                [
                    'game_id' => $game->id
                ],
                $data
            );

            $game_score_status_id = gameScoresStatus('ft-and-ht-results');

            if (in_array($game->game_score_status_id, unsettledGameScoreStatuses())) {

                if (isset($data['home_scores_half_time']) && $data['home_scores_half_time'] >= 0) {
                    $game_score_status_id = gameScoresStatus('ft-and-ht-results');
                    $game->update(['game_score_status_id' => $game_score_status_id, 'status' => GameScoreStatus::find(gameScoresStatus('ft-and-ht-results'))->name]);
                }
                // postponed
                else if ($score->winner == Str::upper('postponed')) {
                    $game_score_status_id = gameScoresStatus('ft-and-ht-results');
                    $game->update(['game_score_status_id' => $game_score_status_id, 'status' => Str::upper('postponed')]);
                }

                // Avoid overwriting
                else if ($score->home_scores_half_time == null) {
                    $game_score_status_id = gameScoresStatus('ft-results-only');
                    $game->update(['game_score_status_id' => $game_score_status_id, 'status' => GameScoreStatus::find(gameScoresStatus('ft-and-ht-results'))->name]);
                }
            }
        }

        return $game_score_status_id;
    }

    private function syncReferees($game, $match)
    {

        if (isset($match->referees)) {

            $referees = $match->referees;
            $refsArr = [];
            foreach ($referees as $referee) {

                $country = Country::where('name', $referee->nationality)->first();

                $ref = Referee::updateOrCreate([
                    'name' => $referee->name,
                    'type' => $referee->type,
                    'country_id' => $country->id ?? 0,
                ]);

                if ($ref) {
                    $refsArr[] = $ref->id;
                }
            }

            $game->referees()->sync($refsArr);
        }
    }

    function prepareFetch($competition_id, $season_id = null)
    {

        if ($season_id) {
            $season = Season::find($season_id);
        } else {
            $season = Season::where('competition_id', $competition_id)->where('is_current', true)->first();
        }

        $season_str = null;
        if ($season)
            $season_str = Str::before($season->start_date, '-') . '-' . Str::before($season->end_date, '-');

        $competition = Competition::whereHas('gameSources', function ($q) use ($competition_id) {
            $q->where('competition_id', $competition_id);
        })->first();

        if (!$competition) {
            $message = 'Competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;

            return response(['message' => $message], 404);
        }

        // Access the source_id value for the pivot
        $source = $competition->gameSources()->where(function ($q) use ($competition_id) {
            $q->where('game_source_id', $this->sourceId)->where('competition_id', $competition_id);
        })->first()->pivot;

        if (!$source) {
            $message = 'Source for competition #' . $competition_id . ' not found.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 404);
        }

        if (!$source->is_subscribed) {
            $message = 'Source #' . $source->source_id . ' not subscribed.';
            if (request()->without_response) return $message;
            return response(['message' => $message], 402);
        }

        return ['message' => true, 'data' => [$competition, $season, $source, $season_str]];
    }

    private function saveGames(&$matches, $competition = null)
    {
        $msg = "";
        $saved = $updated = 0;
        try {

            DB::beginTransaction();

            $date_or_compe_not_found = [];
            $country_not_found = [];
            $competition_not_found = [];
            $home_team_not_found = [];
            $away_team_not_found = [];

            foreach ($matches as $key => &$match) {
                $competition = $competition ?? $match['competition'];
                $country = $competition->country ?? null;
                $season = null;

                if ($competition && $country && $match['date']) {

                    $homeTeam = Team::whereHas('gameSources', function ($q) use ($match) {
                        $q->where('source_uri', $match['home_team']['uri']);
                    })->first();
                    if (!$homeTeam) {
                        $homeTeam = (new TeamsHandler())->updateOrCreate($match['home_team'], $country, $competition, $season, true);
                    }

                    $awayTeam = Team::whereHas('gameSources', function ($q) use ($match) {
                        $q->where('source_uri', $match['away_team']['uri']);
                    })->first();
                    if (!$awayTeam) {
                        $awayTeam = (new TeamsHandler())->updateOrCreate($match['away_team'], $country, $competition, $season, true);
                    }

                    if ($homeTeam && $awayTeam) {

                        // Update the home_team and away_team IDs in the $matches array
                        $match['home_team']['id'] = $homeTeam->id;
                        $match['away_team']['id'] = $awayTeam->id;

                        // All is set can now save game!
                        $result = $this->saveGame($match, $country, $competition, $season, $homeTeam, $awayTeam);

                        // Check the result of the save operation
                        if ($result === 'saved') {
                            $saved++;
                        } elseif ($result === 'updated') {
                            $updated++;
                        }
                    } else {

                        if (!$homeTeam) {

                            if (!isset($home_team_not_found[$country->name])) {
                                $home_team_not_found[$match['home_team']['name']] = 1;
                            } else {
                                $home_team_not_found[$match['home_team']['name']] = $home_team_not_found[$match['home_team']['name']] + 1;
                            }

                            Log::critical('homeTeam not found:', (array) $match['home_team']['name']);
                        }

                        if (!$awayTeam) {

                            if (!isset($away_team_not_found[$country->name])) {
                                $away_team_not_found[$match['away_team']['name']] = 1;
                            } else {
                                $away_team_not_found[$match['away_team']['name']] = $away_team_not_found[$match['away_team']['name']] + 1;
                            }

                            Log::critical('awayTeam not found:', (array) $match['away_team']['name']);
                        }
                    }
                } else {
                    $no_date_mgs = ['competition' => $competition->id ?? null, 'season' => $season ? $season->id : null, 'match' => $match];
                    $date_or_compe_not_found['match'][$key] = $match;
                    Log::critical('Match has no date or competition:', $no_date_mgs);
                }
            }

            DB::commit();

            $msg = "Fetching matches completed, (saved $saved, updated: $updated).";

            if (count($date_or_compe_not_found) > 0) {
                $msg .= ' ' . count($date_or_compe_not_found) . ' dates / competition were not found.';
            }

            if (count($country_not_found) > 0) {
                $msg .= ' ' . count($country_not_found) . ' countries were not found.';
            }

            if (count($competition_not_found) > 0) {
                $msg .= ' ' . count($competition_not_found) . ' competitions were not found.';
            }

            if (count($home_team_not_found) > 0) {
                $msg .= ' ' . count($home_team_not_found) . ' home teams were not found.';
            }

            if (count($away_team_not_found) > 0) {
                $msg .= ' ' . count($away_team_not_found) . ' away teams were not found.';
            }
        } catch (\Exception $e) {
            dd($e);
            DB::rollBack();
            $this->has_errors = true;

            Log::error('Error during data import: ' . $e->getMessage() . ', File: ' . $e->getFile() . ', Line no:' . $e->getLine());
            $msg = 'Error during data import.';
        }

        return [$saved, $updated, $msg];
    }

    private function saveGame($match, $country, $competition, $season, $homeTeam, $awayTeam)
    {
        // Extracting necessary information for creating or updating a game
        $competition_id = $competition->id;
        $season_id = $season->id ?? null;
        $country_id = $country->id;
        $date = Carbon::parse($match['date'] . ' ' . $match['time']);
        $utc_date = $date->format('Y-m-d H:i');

        $has_time = $match['has_time'];
        $status = $date->isFuture() ? 'SCHEDULED' : (Str::contains($match['date'], ':') ? 'PENDING' : 'FINISHED');
        $matchday = null;
        $stage = null;
        $group = null;
        $status_id = activeStatusId();
        $user_id = auth()->id();

        // Prepare data array for creating or updating a game
        $arr = [
            'competition_id' => $competition_id,
            'home_team_id' => $homeTeam->id,
            'away_team_id' => $awayTeam->id,
            'season_id' => $season_id,
            'country_id' => $country_id,
            'utc_date' => $utc_date,
            'has_time' => $has_time,
            'status' => $status,
            'matchday' => $matchday,
            'stage' => $stage,
            'group' => $group,
            'status_id' => $status_id,
            'user_id' => $user_id,
        ];

        $qry = [
            ['competition_id', $competition_id],
            ['home_team_id', $homeTeam->id],
            ['away_team_id', $awayTeam->id],
        ];

        if ($season_id) {
            $qry[] = ['season_id', $season_id];
        }

        // Check if a game with the same details already exists
        $game = Game::query()
            ->whereDate('utc_date', $date->format('Y-m-d'))
            ->where($qry)->first();

        // If the game exists, update it; otherwise, create a new one
        if ($game) {
            $game->update($arr);
            $msg = 'updated';
        } else {
            $game = Game::create($arr);
            $msg = 'saved';
        }

        // Attach game source information to the game if not already attached
        $game_details_uri = $match['game_details']['uri'];

        // Check if the entry already exists in the pivot table
        $query = $game->gameSources()->where('game_source_id', $this->sourceId);
        if (!$query->exists()) {
            $game->gameSources()->attach($this->sourceId, ['source_uri' => $game_details_uri]);
        } elseif ($query->whereNull('source_uri')->exists()) {
            // If the entry exists but the source_uri is NULL, update the source_uri
            $query->update(['source_uri' => $game_details_uri]);
        }

        // Synchronize referees
        $this->syncReferees($game, $match);

        if ($game) {
            $this->storeScores($game, $match['game_details']);
        }

        // Return a message indicating whether the game was saved or updated
        return $msg;
    }
}
